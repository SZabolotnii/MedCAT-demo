# План Етапу (SpaCy без GPU)

## Контекст
- Фаза передбачає роботу виключно на CPU з пайплайном `en_core_web_md` (SpaCy 3.8.7)
- Векторизаційний шар має забезпечувати надійну базу для подальшої еволюції (BERT, GPU)
- Бізнес-потреба: стабільне виділення клінічних сутностей зі швидкістю, що перевищує поточну ручну обробку

## Цілі Етапу
- Отримати якісні та відтворювані ембеддинги на базі SpaCy для основних клінічних сутностей
- Валідувати коректність інтеграції семантичного шару з існуючою бізнес-логікою
- Зібрати базову метрику якості та продуктивності для порівняння з майбутніми векторизаторами
- Налаштувати моніторинг якості та процесів без нарощення технічного боргу

## Архітектурні Принципи
- Модульність: VectorizationEngine з інтерфейсом, що дозволяє гарячий своп векторизаторів
- Ідемпотентність: повторні запускі пайплайнів не повинні створювати побічних ефектів
- Логування та трасування: кожен етап має залишати слід (metrics, audit trail)
- Зосередженість на CPU-оптимізації (низька латентність, невеликий обсяг памʼяті)

## Основні Завдання
### 1. Підготовка Даних
- Узгодити з командою список пріоритетних типів сутностей (класи медичних понять)
- Побудувати мінімум два датасети: `calibration_set` (ручна анотація ~200 документів) та `monitoring_slice`
- Реалізувати скрипт для регулярного оновлення навчальної/валідаційної вибірок (версіонування у `data/`)
- Задокументувати інструкції для анотації (guidelines)

### 2. Побудова SpaCy Vectorizer
- Створити клас `SpaCyVectorizer` у `src/vectorization/spacy_vectorizer.py` з підтримкою:
  - лazy завантаження моделі
  - кешування ембеддингів для повторно використовуваних фрагментів
  - graceful-degradation при відсутності моделі
- Розширити `VectorizationEngine` (інтерфейс) тестами контрактів у `tests/vectorization/test_engine_interface.py`
- Інтегрувати векторизатор у бізнес-логіку (`CustomCAT Integration Layer`) через конфіг-флаг
- Згенерувати векторне представлення існуючих хінтів (keywords/value hints) та сформувати уніфікований `concept_lexicon` у `data/hints/hint_lexicon.json`
- Додати компонент `HintNER` (комбінує `PhraseMatcher` + cosine similarity пошук по векторизованих хінтах) у пайплайн перед стандартним `ner`
- Передбачити API для повернення додаткових атрибутів (`Span._.hint_id`, confidence) для інтеграції з бізнес-логікою

### 3. Алгоритмічна Інтеграція
- Налаштувати витяг сутностей (`Entity Detection Orchestration`) так, щоб він міг вмикати/вимикати SpaCy-прохід
- Валідувати роботу теггерів та лематизатора для медичних термінів, при потребі додати кастомні правила (attribute_ruler)
- Реалізувати механізм пост-обробки ембеддингів: нормалізація, обрізання до потрібної розмірності, агрегація на рівні документа
- Документувати API для доступу до векторів та сценарії їх використання в системі
- Інтегрувати результати `HintNER`: розвʼязання конфліктів між перетинними span-ами, пріоритизація найвищого скору, мапінг на canonical value

### 4. Метрики якості та продуктивності
- Визначити KPI: Precision/Recall/F1 на `calibration_set`, середній час обробки документа, споживання памʼяті
- Створити утиліту `scripts/evaluate_spacy.py` з репортом у форматі Markdown/JSON
- Автоматизувати запуск тестів якості (GitHub Actions / локальний CI) з падінням пайплайну при регресії
- Налаштувати lightweight дашборд (наприклад, Metabase/Looker Studio) або хоча б Jupyter-ноутбук з візуалізацією трендів
- Додати `scripts/evaluate_hint_ner.py` для оцінювання компоненту `HintNER` на автоматично згенерованих прикладах та `calibration_set`
- Зібрати тестовий набір із 20–30 речень для швидкого sanity-check роботи `HintNER` та порівняння з baseline SpaCy NER

### 5. Моніторинг та Операційні Практики
- Впровадити логування ключових помилок у `reports/` (failed entities, confidence < threshold)
- Налаштувати алертинг при різкому падінні метрик або збільшенні латентності
- Створити чеклист деплою (прогін тестів, оновлення моделі, синхронізація конфігів)
- Підготувати fallback-процедуру: як переключитися на попередню модель/версію
- Забезпечити audit trail для автоматично знайдених ентіті: ID хінта, score, дата обробки (для подальшого ручного ревʼю)

### 6. Комунікація та Управління
- Визначити контактних осіб з боку бізнесу та медичних експертів, зібрати регулярні зворотні звʼязки
- Описати процес ескалації проблем (блокери, інциденти), включити SLA на відповідь
- Проводити демо кожного завершеного підетапу (data prep, vectorizer, evaluation) з фіксацією рішень у `info/meeting_notes`
- Підготувати навчальні матеріали для команди (коротка інструкція з використання SpaCy у проекті)

## Чекпоїнти
- **Checkpoint A (Тиждень 1):** завершені датасети та guidelines, проходить smoke-test на 10 документах
- **Checkpoint B (Тиждень 2):** працюючий `SpaCyVectorizer`, інтеграція у бізнес-логіку, базові юніт-тести
- **Checkpoint C (Тиждень 3):** звіт з метриками, налаштований моніторинг, демо для стейкхолдерів
- **Checkpoint D (Тиждень 4):** стабілізована продуктивність, документований fallback, готовність до А/Б-тестів у Phase 1B.2

## Ризики та Мітігації
- **Нестача якісних анотацій:** ранній запуск анотаційної кампанії, ревʼю медичним експертом
- **Ліміт продуктивності CPU:** профілювання під навантаженням, кешування та оптимізація пайплайнів
- **Комунікаційні розриви з бізнесом:** щотижневі sync-и, протоколювання рішень
- **Раптовий перехід до GPU:** заготовлені конфігураційні прапорці та інструкції з інфраструктури

## Артефакти та Документація
- `data/README.md` — опис датасетів і схем анотацій
- `src/vectorization/spacy_vectorizer.py` — реалізація векторизатора
- `scripts/evaluate_spacy.py` — скрипт оцінки
- `reports/spacy_baseline_metrics.md` — звіт з метриками
- `info/meeting_notes/*.md` — лог прийнятих рішень

## Визначення Успіху
- F1 ≥ 0.80 на `calibration_set`, латентність ≤ 70 мс/документ
- Готовий до продакшену fallback механізм та процес інцидент-менеджменту
- Бізнес-експерти підтверджують, що точність достатня для ручного пост-контролю
- Команда володіє знаннями для переходу до BERT, маючи технічні та процесні основи
